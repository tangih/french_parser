Probabilistic French parser
========================================

## Introduction

This repositery is an implementation of a probabilistic parser for French natural sentences. The parser is based on the SEQUOIA dataset [^f1]

### Usage

## PCFG extraction

### Dataset

We extract a probabilistic context-free grammar by parsing the SEQUOIA treebank dataset~\cite{candito2012corpus}. The dataset is given as a bracketed set of 3099 lines corresponding to sentences and the associated grammatical structure of the sentence. The PCFG is created by counting the number of times the rules have been seen associated to a certain head. Overall, we find 2929 different rules in the dataset.

### Chomsky normal form

In order to apply the CYK algorithm for probabilistic parsing, we need to convert our PCFG into Chomsky normal form \cite{chomsky1959certain}, that is to say rules have to be of the form
$$
\begin{array}{ll}
     A \to BC & \text{or}\\
    A \to a & \text{or}\\
    S \to \epsilon
    \end{array}
$$

where $$$A$$$, $B$ and $C$ are non-terminal symbols, and $a$ is a terminal symbol. To convert our PCFG into normal form, we have to apply a certain set of rules~\cite{lange2009cnf}:
 - START: eliminate start symbols from right hand side
 
 - TERM: eliminate rules with non-solitary terminals
 
 - BIN: replace each rule
$$
 A \rightarrow X_1 ... X_n
 $$
with associated probability $p$ by a set of rules
$$
 \begin{array}{ll}
   A\rightarrow X_1A_1 & \text{with associated probability $p$}\\
A_1\rightarrow X_2A_2 & \text{with associated probability 1}\\
...\\
A_{n-2}\rightarrow X_{n-1}X_n & \text{with associated probability 1}\\\end{array}
    $$
    
 - UNIT: eliminate unit rules. A unit rule is a rule of the form 
$$
A\rightarrow B
$$
with associated probability $p$, where $A$, $B$ are non-terminal symbols. To remove it, for each rule 
$$
B\rightarrow X_1 ... X_n
$$
where $X_1 ... X_n$ is a string of nonterminals and terminals with associated probability $p'$, add rule 
$$
A\rightarrow X_1 ... X_n
$$
with associated probability $pp'$.
Notice this rule is problematic, since even though the language generated by the PCFG is still the same after applying this rule, when applying the algorithm we will not be able to reconstruct the intermediate rules. The way to overcome this problem is by remembering the rules $A\to A_1\to ... \to A_m \to X_1 ... X_n$ we erase: when generating the parse, we can either choose the rule with maximal probability, or randomly sample one of these rules with the distribution associated to the probabilities of these sequences of rules.
\end{enumerate}



## OOV module

We want our parser to be able to handle unknown words, which means we need to identify the part-of-speech tags associated to words we did not encountered in the dataset. We can identify two causes for encountering an unknown word: the first is we genuinely never encoutered the word, and the second is that there is a spelling mistake in the input word. For these reasons, we are going to build two modules: the first one is basically a spell correcter, that returns a list of most probable corrections for an input word, and the second one is a similarity measure between words.

### Spell checker

To compute candidates for spelling correction, we are going to search for words that are at distance at most 2 from the input word, where the distance between two words is given by the minimal number of transformations to go from one to the other. The allowed transformations are insertion of a character, deletion of a caracter, and substitution of two characters. This distance, called the Levenshtein distance~\cite{levenshtein1966binary}, can be easily computed by a dynamic programming algorithm. If we denote by $\text{lev}_{a, b}(i, j)$ the number of operations necessary to go from the $i$-prefix of $a$ to the $j$-prefix of $b$, we have:
$$
\text{lev}_{a, b}(i, j) = 
    \left\{
        \begin{array}{ll}
            \max(i, j) &  \text{if } \min(i, j) = 0\\
            \min \left\{
                \begin{array}{l}
                    \text{lev}_{a, b}(i-1, j) + 1\\
                    \text{lev}_{a, b}(i, j-1) + 1\\
                    \text{lev}_{a, b}(i-1, j-1) + 1_{(a_i \neq b_i)}
                \end{array}
                \right.
        \end{array}
    \right.
$$

In addition to this, we are going to compute the probability of a given candidate word to be mistakenly spelled as the input word. To do so, we are going to use the spelling noisy model in \cite{kernighan1990spelling}. This paper gives tables with frequencies of a given insertion/deletion/substitution error to happen. This allows us to compute the probability associated to a candidate. Given an input word $t$ and a candidate $c$, Bayes rule yields:
$$
  P(c|t) = \underbrace{P(t|c)}_{\text{mistake model}}\times\underbrace{P(c)}_{\text{language model}}
$$

The mistake model in the previous equation corresponds to a certain spelling error happening, and can easily be computed by adapting the function used for computing the Levenshtein distance, since the computation of the minimum corresponds to identifying one of the three allowed transformations, and thus the probability associated to this transformation can be used. If we denote $P_{a, b}(i, j)$ the probability of mistakenly typing the $j$-prefix of $b$ instead of the $i$-prefix of $a$, and we denote $P_{del}(i, j)$, $P_{add}(i, j)$ and $P_{sub}(i, j)$ the probabilities of respectively deletion, addition and substitution of $a_i$ instead of $b_j$, and name case 1, 2, 3 the cases corresponding to the min in the definition of the Levenshtein distance, we have

$$
P_{a, b}(i, j) = 
    \left\{
        \begin{array}{ll}
            P_{a, b}(i-1, 0) P_{del}(i, 0) &\text{if j = 0}\\
            P_{a, b}(0, j-1)  P_{add}(0, j) &\text{if i = 0}\\

            \min \left\{
                \begin{array}{ll}
                    P_{a, b}(i-1, j) P_{del}(i, j) & \text{in case 1}\\
                    P_{a, b}(i, j-1) P_{add}(i, j) & \text{in case 2}\\
                    P_{a, b}(i-1, j-1) P_{sub}(i, j)^{1_{(a_i \neq b_i)}} & \text{in case 3}
                \end{array}
                \right.
        \end{array}
    \right.
$$

This allows us to implement a dynamic programming algorithm that computes the levenshtein distance between two words, and the probability associated to this mistake.

We know need to implement a language model. This language model corresponds to the probability to inserting the candidate given the context of the sentence. We could use 1-gram or 2-gram probabilities $P_{uni}$ and $P_{bi}$, but we are going to use an intermediate interpolated probability


$$
\begin{array}{c}
P_{li}(w_k|w_{k-1}) = \lambda P_{uni}(w_k) + (1-\lambda)P_{mle}(w_k|w_{k-1}) \\
\text{where }P_{mle}(w_k|w_{k-1}) = \frac{\#(w_k|w_{k-1})}{\#(w_{k-1})}
\end{array}
$$

We also use add-1 smoothing to allow for unseen sequences. Recombining the two models, we can compute a list of candidates, by computing the Levenshtein distance between all words in our lexicon and the input word, and only keeping the words at a distance of at most 1 (or 2).

### Polyglot similarity

The limit of the previous approach is that our list may be empty, or the obtained candidates may be highly improbable. In that case, it is reasonable to think that the input word is actually not a mistake, but is absent from our lexicon. In that case, we are going to use word embedding to compute a similarity between words. We are going to use the polyglot dataset \cite{al2013polyglot}. Without going into too much detail, this is a light embedding that allows to encode both syntactic and semantic information about the words, as illustrated figure \ref{fig:features}.

| syntactic (global level) clustering |  semantic (local level) clustering |
|-------------------------------------|------------------------------------|
|![](images/polyglot.png) | ![](images/polyglot_semantic.png) |



In the case where the word is not obtained by simple spelling correction, we get its PoS by voting over its $k$ nearest neighbours in the lexicon, according to $L_2$ distance between word embeddings.

### PoS attribution


The spell checker gives us a set of candidates $c_{i, \text{spell}}$ and associated weights $w_{i, \text{spell}}$. Similarly, the words embedding gives us a set of candidates $c_{i, \text{embed}}$ with associated weights $w_{i, \text{embed}}$. The probability of the event $\langle c_i, t \rangle$ the candidate $c_i$ and $t$ share the same PoS is defined as

$$
\begin{split}
 \mathbb{P}(\langle c_{i, \text{spell}}, t \rangle) &= \alpha \cdot \frac{w_{i, \text{spell}}}{\sum_{j, \text{spell}}w_{j, \text{spell}}}\\
 \mathbb{P}(\langle c_{i, \text{embed}}, t \rangle) &= (1 - \alpha) \cdot \frac{w_{i, \text{embed}}}{\sum_{j, \text{embed}}w_{j, \text{embed}}}
\end{split}
$$

with $0 \leq \alpha \leq 1$. Finally, the probability of $t$ having the PoS $p$ is given by

$$
 \begin{split}
 \mathbb{P}(p|t) &= \sum_{i, \text{candidates}}\mathbb{P}(p|c_i)\mathbb{P}(\langle c_i, t \rangle)\\
 &= \sum_{i, \text{candidates}}\mathbb{P}(c_i|p)\mathbb{P}(p)\mathbb{P}(\langle c_i, t \rangle)
 \end{split}
$$

## Parsing

### Probabilistic CYK algorithm

The Cocke-Younger-Kasami (CYK) algorithm \cite{cocke1970programming, younger1967recognition, kasami1966efficient} is a parsing algorithm for context-free grammars. For a given sentence and a CFG in Chomsky normal form, the algorithm returns whether or not the input sentence can be generated from the CFG. We implement a probabilistic version of this algorithm, giving the most probable parse of the input sentence, if it exists. The pseudocode of the algorithm can be found in algorithm \ref{alg:cyk}.

![](images/algo.png)

The parse can then be inferred using the array \texttt{back}. The worst-case complexity of the algorithm is $O(n^3 \cdot |G|)$.

## Bibliography

[^f1]: footnote
